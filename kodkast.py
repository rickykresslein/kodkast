# Title: Kodkast
# Author: Ricky Kresslein
# Author URL: https://kressle.in
# Project URL: https://kressle.in/projects/kodkast/
# Version: 0.8.9

import sys
import time
import vlc
import urllib.request
import os
import ssl
import peewee
import base64
import itunes
import requests
import certifi
import validators
from bs4 import BeautifulSoup
from models import PodcastDB, EpisodeDB
from datetime import date, datetime, timedelta
from PyQt5 import QtWidgets as qtw
from PyQt5 import QtGui as qtg
from PyQt5 import QtCore as qtc

# Logo in base64
image_base64 = b"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"


# Class gratefully provided by MegasXLR on Python-forum.io
# https://python-forum.io/Thread-PyQt-QSlider-jump-to-mouse-click-position
class QJumpSlider(qtw.QSlider):
    def __init__(self, parent=None):
        super(QJumpSlider, self).__init__(parent)
     
    def mousePressEvent(self, event):
        # Jump to click position
        mw.set_position(qtw.QStyle.sliderValueFromPosition(self.minimum(), self.maximum(), event.x(), self.width()))
        self.setValue(qtw.QStyle.sliderValueFromPosition(self.minimum(), self.maximum(), event.x(), self.width()))
     
    def mouseMoveEvent(self, event):
        # Jump to pointer position while moving
        mw.set_position(qtw.QStyle.sliderValueFromPosition(self.minimum(), self.maximum(), event.x(), self.width()))
        self.setValue(qtw.QStyle.sliderValueFromPosition(self.minimum(), self.maximum(), event.x(), self.width()))


class QClickLabel(qtw.QLabel):
    clicked = qtc.pyqtSignal()

    def mousePressEvent(self, event):
        self.clicked.emit()
        qtw.QLabel.mousePressEvent(self, event)


# Class gratefully provided by eyllanesc on Stack Overflow and modified by me
# https://stackoverflow.com/questions/46505130/creating-a-marquee-effect-in-pyside
class QMarqueeLabel(qtw.QLabel):
    def __init__(self, parent=None):
        qtw.QLabel.__init__(self, parent)
        self.px = 0
        self.py = 15
        self._direction = qtc.Qt.LeftToRight
        self.setWordWrap(True)
        self.timer = qtc.QTimer(self)
        self.timer.timeout.connect(self.update)
        self.timer.start(30)
        self._speed = 2
        self.textLength = 0
        self.fontPointSize = 0
        self.setAlignment(qtc.Qt.AlignVCenter)
        self.setFixedHeight(self.fontMetrics().height())

    def setFont(self, font):
        qtw.QLabel.setFont(self, font)
        self.setFixedHeight(self.fontMetrics().height())

    def updateCoordinates(self):
        align = self.alignment()
        if align == qtc.Qt.AlignTop:
            self.py = 10
        elif align == qtc.Qt.AlignBottom:
            self.py = self.height() - 10
        elif align == qtc.Qt.AlignVCenter:
            self.py = self.height() / 2
        self.fontPointSize = self.font().pointSize() / 2
        self.textLength = self.fontMetrics().horizontalAdvance(self.text())

    def setAlignment(self, alignment):
        self.updateCoordinates()
        qtw.QLabel.setAlignment(self, alignment)

    def resizeEvent(self, event):
        self.updateCoordinates()
        qtw.QLabel.resizeEvent(self, event)

    def paintEvent(self, event):
        painter = qtg.QPainter(self)
        if self._direction == qtc.Qt.RightToLeft:
            self.px -= self.speed()
            if self.px <= -self.textLength:
                self.px = self.width()
        else:
            self.px += self.speed()
            if self.px >= self.width():
                self.px = -self.textLength
        painter.drawText(self.px, round(self.py + self.fontPointSize), self.text())
        painter.translate(self.px, 0)

    def speed(self):
        return self._speed

    def setSpeed(self, speed):
        self._speed = speed

    def setDirection(self, direction):
        self._direction = direction
        if self._direction == qtc.Qt.RightToLeft:
            self.px = 300
        else:
            self.px = 0
        self.update()

    def pause(self):
        self.timer.stop()

    def unpause(self):
        self.timer.start()


class MainWindow(qtw.QMainWindow):

    def __init__(self):
        """MainWindow Constructor"""
        super().__init__()
        
        self.setWindowTitle('Kodkast')
        icon = self.icon_from_base64(image_base64)
        self.setWindowIcon(icon)
        self.resize(355, 700)
        self.setFixedWidth(355)
        self.start_width_resize = self.width() - 5

        self.headers = {'User-Agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11',}
        self.track = None
        self.player = None
        self.is_paused = False
        self.ptt_to_prt = False
        self.playback_speed_val = 1
        self.podcasts_old = []
        self.currently_top_100 = False
        self.timer = qtc.QTimer(self)
        self.timer.setInterval(500)
        self.timer.timeout.connect(self.update_ui)
        self.old_image = ""
        self.already_saved = -1
        
        self.set_vlc_dir()

        self.initiate_database()

        self.build_menu_bar()
        self.build_library_view()

        self.show()

    @staticmethod
    def set_vlc_dir():
        """
        Set the directory of VLC Plugins for the OS and warn user
        if it is not installed.
        """
        # Ignore unverified URL errors
        ssl._create_default_https_context = ssl._create_unverified_context

        # VLC not installed warning dialog
        vlc_not_installed = qtw.QMessageBox()
        vlc_not_installed.setIcon(qtw.QMessageBox.Warning)
        vlc_not_installed.setText("VLC is not installed on your computer. Kodkast requires VLC.")
        vlc_not_installed.setInformativeText("You can download VLC from https://www.videolan.org/vlc/")
        vlc_not_installed.setWindowTitle("VLC Not Found")

        # Find and set the VLC_PLUGIN_PATH directory
        if sys.platform == "linux" or sys.platform == "linux2":
            # linux
            if os.path.isdir("/usr/lib64/vlc/plugins"):
                os.environ["VLC_PLUGIN_PATH"] = "/usr/lib64/vlc/plugins"
            elif os.path.isdir("/usr/lib/x86_64-linux-gnu/vlc/plugins"):
                os.environ["VLC_PLUGIN_PATH"] = "/usr/lib/x86_64-linux-gnu/vlc/plugins"
            elif os.path.isdir("/usr/lib/vlc/plugins"):
                os.environ["VLC_PLUGIN_PATH"] = "/usr/lib/vlc/plugins"
            elif os.path.isdir("/usr/lib32/vlc/plugins"):
                os.environ["VLC_PLUGIN_PATH"] = "/usr/lib32/vlc/plugins"
            else:
                # VLC is not installed
                vlc_not_installed.exec_()
        elif sys.platform == "darwin":
            # mac
            if os.path.isdir("/Applications/VLC.app/Contents/MacOS/plugins"):
                os.environ["VLC_PLUGIN_PATH"] = "/Applications/VLC.app/Contents/MacOS/plugins"
            else:
                # VLC not installed
                vlc_not_installed.exec_()

    @staticmethod
    def initiate_database():
        try:
            PodcastDB.create_table()
        except peewee.OperationalError:
            pass
        
        try:
            EpisodeDB.create_table()
        except peewee.OperationalError:
            pass

    def build_menu_bar(self):
        menubar = self.menuBar()

        file_menu = menubar.addMenu("File")
        file_menu.addAction('Quit', qtw.QApplication.quit, qtg.QKeySequence.Quit)

        podcasts_menu = menubar.addMenu("Podcasts")
        self.add_podcast_action = podcasts_menu.addAction('Add a new podcast', self.build_add_podcast)
        self.add_podcast_action.setShortcut('Ctrl+A')
        self.remove_podcast_action = podcasts_menu.addAction('Remove podcast', lambda: self.remove_podcast(self.lib_podcasts.currentItem().text()))

        episodes_menu = menubar.addMenu("Episodes")
        self.refresh_episodes_action = episodes_menu.addAction('Refresh episode list', self.load_episodes_from_feed)
        self.refresh_episodes_action.setShortcut('Ctrl+R')
        self.refresh_episodes_action.setEnabled(False)

        self.play_shortcut = qtw.QShortcut(qtg.QKeySequence("Space"), self)
        self.play_shortcut.activated.connect(self.play_episode_shortcut)
        self.play_pause_key = qtw.QShortcut(qtg.QKeySequence(qtc.Qt.Key_MediaPlay), self)
        self.play_pause_key.activated.connect(self.play_episode_shortcut)

    def build_library_view(self):
        self.refresh_episodes_action.setEnabled(False)
        self.library_layout = qtw.QWidget()
        self.library_layout.setLayout(qtw.QVBoxLayout())
        self.resize(355, 700)

        lib_title = qtw.QLabel('Library')
        self.to_play_view_btn = qtw.QPushButton('➡', clicked=self.to_play_view)
        self.to_play_view_btn.setFixedWidth(50)
        self.lib_podcasts = qtw.QListWidget()
        self.lib_podcasts.setViewMode(qtw.QListView.IconMode)
        self.lib_podcasts.setIconSize(qtc.QSize(130,130))
        self.lib_podcasts.setMovement(False)
        self.lib_podcasts.setResizeMode(qtw.QListView.Adjust)
        self.lib_podcasts.setSpacing(11)
        self.lib_podcasts.setUniformItemSizes(True)
        self.lib_podcasts.doubleClicked.connect(lambda: self.build_episode_view(self.lib_podcasts.currentItem().text()))
        self.lib_podcasts.setContextMenuPolicy(qtc.Qt.CustomContextMenu)
        self.lib_podcasts.customContextMenuRequested.connect(self.library_context_menu)
        self.lib_add = qtw.QPushButton('Add Podcast', clicked=self.build_add_podcast)

        title_line = qtw.QWidget()
        title_line.setLayout(qtw.QHBoxLayout())
        title_line.layout().addWidget(lib_title, alignment=qtc.Qt.AlignLeft)
        if self.player and self.player.is_playing():
            title_line.layout().addWidget(self.to_play_view_btn, alignment=qtc.Qt.AlignRight)
        self.library_layout.layout().addWidget(title_line)
        self.library_layout.layout().addWidget(self.lib_podcasts)
        self.library_layout.layout().addWidget(self.lib_add)
        # Show mini player if podcast is already playing
        self.build_mini_player(self.library_layout)
        self.setCentralWidget(self.library_layout)
        self.add_podcast_action.setEnabled(True)
        self.remove_podcast_action.setEnabled(True)

        self.refresh_podcast_list()
    
    def refresh_podcast_list(self):
        query = PodcastDB.select()
        self.lib_podcasts.clear()
        for podcast in query:
            if not podcast.rendered:
                request=urllib.request.Request(podcast.image, None, self.headers)
                response = urllib.request.urlopen(request)
                url_image = response.read()
                b64_img = base64.b64encode(url_image)
                podcast.rendered = b64_img
                podcast.save()
            podcast_pmap = qtg.QPixmap()
            podcast_pmap.loadFromData(base64.b64decode(podcast.rendered))
            podcast_icon = qtg.QIcon(podcast_pmap)
            this_podcast = qtw.QListWidgetItem(podcast.title, self.lib_podcasts)
            this_podcast.setStatusTip(podcast.title)
            this_podcast.setIcon(podcast_icon)
            this_podcast.setSizeHint(qtc.QSize(140, 150))
            
    def build_add_podcast(self):
        qtw.QApplication.setOverrideCursor(qtc.Qt.WaitCursor)
        self.currently_top_100 = False
        self.refresh_episodes_action.setEnabled(False)
        self.add_podcast_action.setEnabled(False)
        self.remove_podcast_action.setEnabled(False)
        
        self.add_podcast_layout = qtw.QWidget()
        self.add_podcast_layout.setLayout(qtw.QVBoxLayout())

        back_to_pod_list = qtw.QPushButton("⬅", clicked=self.build_library_view)
        back_to_pod_list.setFixedWidth(50)
        search_itunes_title = qtw.QLabel('Search iTunes:')
        search_box = qtw.QLineEdit()
        search_button = qtw.QPushButton('Search', clicked=lambda: self.search_itunes(search_box.text()))
        search_button.setFixedWidth(100)
        search_box.returnPressed.connect(search_button.click)
        add_by_url_title = qtw.QLabel('Add by URL:')
        url_box = qtw.QLineEdit()
        add_by_url_button = qtw.QPushButton('Add', clicked=lambda: self.add_podcast_to_library(url_box.text(),url_add=True))
        add_by_url_button.setFixedWidth(100)
        url_box.returnPressed.connect(add_by_url_button.click)
        top_100_button = qtw.QPushButton('iTunes Top 100', clicked=self.show_top_100)
        self.results_list = qtw.QListWidget()
        self.results_list.setViewMode(qtw.QListView.IconMode)
        self.results_list.setIconSize(qtc.QSize(130,130))
        self.results_list.setMovement(False)
        self.results_list.setResizeMode(qtw.QListView.Adjust)
        self.results_list.setSpacing(11)
        self.results_list.setUniformItemSizes(True)
        self.results_list.doubleClicked.connect(lambda: self.add_podcast_to_library(
                                                 self.results_lod[self.results_list.currentRow()]
                                                ))
        self.results_list.setContextMenuPolicy(qtc.Qt.CustomContextMenu)
        self.results_list.customContextMenuRequested.connect(self.search_context_menu)
        subscribe_button = qtw.QPushButton('Subscribe', clicked=lambda: self.add_podcast_to_library(
                                                            self.results_lod[self.results_list.currentRow()]
                                                        ))
        
        search_line_layout = qtw.QWidget()
        search_line_layout.setLayout(qtw.QHBoxLayout())
        search_line_layout.layout().addWidget(search_box)
        search_line_layout.layout().addWidget(search_button)
        
        url_line_layout = qtw.QWidget()
        url_line_layout.setLayout(qtw.QHBoxLayout())
        url_line_layout.layout().addWidget(url_box)
        url_line_layout.layout().addWidget(add_by_url_button)
        
        self.add_podcast_layout.layout().addWidget(back_to_pod_list)
        self.add_podcast_layout.layout().addWidget(add_by_url_title)
        self.add_podcast_layout.layout().addWidget(url_line_layout)
        self.add_podcast_layout.layout().addWidget(search_itunes_title)
        self.add_podcast_layout.layout().addWidget(search_line_layout)
        self.add_podcast_layout.layout().addWidget(top_100_button)
        self.add_podcast_layout.layout().addWidget(self.results_list)
        self.add_podcast_layout.layout().addWidget(subscribe_button)
        # Show mini player if podcast is already playing
        self.build_mini_player(self.add_podcast_layout)
        self.setCentralWidget(self.add_podcast_layout)
        
        search_box.setFocus()

        qtw.QApplication.restoreOverrideCursor()
        
    def search_itunes(self, search_query):
        qtw.QApplication.setOverrideCursor(qtc.Qt.WaitCursor)
        self.currently_top_100 = False
        self.results_list.clear()
        self.results_lod = []
        result_limit = 0
        results = itunes.search(query=search_query, media='podcast')
        for result in results:
            if result_limit < 50:
                # Only show results that have the necessary keys
                if result.json.keys() >= {"artworkUrl600", "feedUrl"}:
                    # Get title, picture, and url for each podcast that has them
                    result_dict = {'title': result.name, 'image': result.artwork['600'], 'url': result.json['feedUrl']}
                    # Store all this data in a variable (list of dicts) in order to recal the feed url
                    self.results_lod.append(result_dict)
                    
                    # Display title and picture
                    request = urllib.request.Request(result_dict['image'], None, self.headers)
                    response = urllib.request.urlopen(request)
                    url_image = response.read()
                    podcast_pmap = qtg.QPixmap()
                    podcast_pmap.loadFromData(url_image)
                    podcast_icon = qtg.QIcon(podcast_pmap)
                    this_podcast = qtw.QListWidgetItem(result_dict['title'], self.results_list)
                    this_podcast.setStatusTip(result_dict['title'])
                    this_podcast.setIcon(podcast_icon)
                    this_podcast.setSizeHint(qtc.QSize(140, 150))
                    result_limit += 1
            else:
                break
        qtw.QApplication.restoreOverrideCursor()
        
    def add_podcast_to_library(self, ap_selection, url_add=False):
        qtw.QApplication.setOverrideCursor(qtc.Qt.WaitCursor)
        if not url_add:
            if self.currently_top_100:
                ap = itunes.lookup(int(ap_selection['id']))
                if ap.json.keys() >= {"feedUrl"}:
                    ap_url = ap.json['feedUrl']
                else:
                    qtw.QApplication.restoreOverrideCursor()
                    self.invalid_url_warning()
                    return
            else:
                ap_url = ap_selection['url']
        else:
            ap_url = ap_selection

        if validators.url(ap_url):
            feed_req = requests.get(ap_url)
            try:
                feed = BeautifulSoup(feed_req.content, features='xml')
                feed_title = feed.find('title').text
                if url_add:
                    try:
                        feed_image = feed.find('image')['href']
                    except KeyError:
                        feed_image = feed.find('image').find('url').text
                else:
                    try:
                        feed_image = feed.find('image').find('url').text
                    except:
                        feed_image = feed.find('image')['href']
                query = PodcastDB.select().where(PodcastDB.title == feed_title)
                if query.exists():
                    qtw.QApplication.restoreOverrideCursor()
                    exists_msg = qtw.QMessageBox()
                    exists_msg.setIcon(qtw.QMessageBox.Information)
                    exists_msg.setWindowTitle("Already Exists")
                    exists_msg.setText("You are already subscribed to that podcast.")
                    exists_msg.exec_()
                else:
                    PodcastDB.create(title=feed_title, url=ap_url, image=feed_image)
                    qtw.QApplication.restoreOverrideCursor()
                self.build_library_view()
            except AttributeError:
                qtw.QApplication.restoreOverrideCursor()
                self.invalid_url_warning()
        else:
            # VLC not installed warning dialog
            qtw.QApplication.restoreOverrideCursor()
            self.invalid_url_warning()
        
        
    def invalid_url_warning(self):
        invalid_url = qtw.QMessageBox()
        invalid_url.setIcon(qtw.QMessageBox.Critical)
        invalid_url.setText("The URL you entered is invalid.")
        invalid_url.setInformativeText("Please enter a valid Podcast RSS feed URL")
        invalid_url.setWindowTitle("Invalid URL")
        invalid_url.exec_()
        
    def show_top_100(self):
        qtw.QApplication.setOverrideCursor(qtc.Qt.WaitCursor)
        self.currently_top_100 = True
        self.results_list.clear()
        self.results_lod = []
        results = requests.get('https://rss.itunes.apple.com/api/v1/us/podcasts/top-podcasts/all/100/explicit.json', verify=certifi.where()).json()
        results = results['feed']['results']
        for result in results:
            # Only show results that have the necessary keys
            if result.keys() >= {"artworkUrl100", "url"}:
                # Get title, picture, and url for each podcast that has them
                result_dict = {'title': result['name'], 'image': result['artworkUrl100'], 'id': result['id']}
                # Store all this data in a variable (list of dicts) in order to recal the feed url
                self.results_lod.append(result_dict)
                
                # Display title and picture
                request=urllib.request.Request(result_dict['image'], None, self.headers)
                response = urllib.request.urlopen(request)
                url_image = response.read()
                podcast_pmap = qtg.QPixmap()
                podcast_pmap.loadFromData(url_image)
                podcast_icon = qtg.QIcon(podcast_pmap)
                this_podcast = qtw.QListWidgetItem(result_dict['title'], self.results_list)
                this_podcast.setStatusTip(result_dict['title'])
                this_podcast.setIcon(podcast_icon)
                this_podcast.setSizeHint(qtc.QSize(140, 150))
        qtw.QApplication.restoreOverrideCursor()

    def remove_podcast(self, current_podcast):
        qtw.QApplication.setOverrideCursor(qtc.Qt.WaitCursor)
        current_podcast = PodcastDB.select().where(PodcastDB.title==current_podcast).get()
        current_podcast.delete_instance()
        query = EpisodeDB.select().where(EpisodeDB.podcast == current_podcast)
        if query.exists():
            for episode in query:
                episode.delete_instance()
        self.refresh_podcast_list()
        qtw.QApplication.restoreOverrideCursor()

    def build_episode_view(self, current_podcast):
        self.current_podcast = PodcastDB.select().where(PodcastDB.title==current_podcast).get()
        self.add_podcast_action.setEnabled(False)
        self.remove_podcast_action.setEnabled(False)
        episode_layout = qtw.QWidget()
        episode_layout.setLayout(qtw.QVBoxLayout())
        self.resize(355, 700)

        back_to_pod_list = qtw.QPushButton("⬅", clicked=self.build_library_view)
        back_to_pod_list.setFixedWidth(50)
        self.to_play_view_btn = qtw.QPushButton('➡', clicked=self.to_play_view)
        self.to_play_view_btn.setFixedWidth(50)
        bak_fwd_layout = qtw.QWidget()
        bak_fwd_layout.setLayout(qtw.QHBoxLayout())
        bak_fwd_layout.layout().addWidget(back_to_pod_list, alignment=qtc.Qt.AlignLeft)
        if self.player and self.player.is_playing():
            bak_fwd_layout.layout().addWidget(self.to_play_view_btn, alignment=qtc.Qt.AlignRight)

        title_label = qtw.QLabel(self.current_podcast.title)
        self.ep_list = qtw.QTableWidget()
        self.ep_list.setColumnCount(2)
        self.ep_list.setHorizontalHeaderLabels(['Date', 'Title'])
        self.ep_list.horizontalHeaderItem(0).setTextAlignment(qtc.Qt.AlignLeft)
        self.ep_list.horizontalHeaderItem(1).setTextAlignment(qtc.Qt.AlignLeft)
        self.ep_list.setSelectionBehavior(qtw.QAbstractItemView.SelectRows)
        self.ep_list.verticalHeader().setVisible(False)
        self.ep_list.setSelectionMode(qtw.QAbstractItemView.SingleSelection)
        self.ep_list.setAutoScroll(False)
        self.ep_list.setShowGrid(False)
        self.ep_list.doubleClicked.connect(lambda: self.build_play_view(self.ep_list.item(self.ep_list.currentRow(),1).text()))
        self.ep_list.setContextMenuPolicy(qtc.Qt.CustomContextMenu)
        self.ep_list.customContextMenuRequested.connect(self.episode_context_menu)
        self.ep_list_play = qtw.QPushButton("Play", clicked=lambda: self.build_play_view(self.ep_list.item(self.ep_list.currentRow(),1).text()))

        episode_layout.layout().addWidget(bak_fwd_layout)
        episode_layout.layout().addWidget(title_label)
        episode_layout.layout().addWidget(self.ep_list)
        episode_layout.layout().addWidget(self.ep_list_play)
        self.build_mini_player(episode_layout)
        self.setCentralWidget(episode_layout)
        
        query = EpisodeDB.select().where(EpisodeDB.podcast == self.current_podcast)
        if query.exists():
            # If podcast episode lists exists, load it.
            self.refresh_episode_list()
            # If latest episode is older than 6 days, check for new episodes
            latest_text = self.ep_list.item(0,0).text()
            if latest_text != "Today" and latest_text != "Yesterday":
                newest_episode = datetime.strptime(latest_text, "%m-%d-%Y")
                time_since_newest = datetime.now() - newest_episode
                if time_since_newest.days > 6:
                    self.load_episodes_from_feed()
        else:
            # Otherwise, build a new list from the feed.
            self.load_episodes_from_feed()
        self.refresh_episodes_action.setEnabled(True)        

    def load_episodes_from_feed(self):
        qtw.QApplication.setOverrideCursor(qtc.Qt.WaitCursor)
        show_error = False
        query = EpisodeDB.select().where(EpisodeDB.podcast == self.current_podcast)

        feed_req = requests.get(self.current_podcast.url)
        feed = BeautifulSoup(feed_req.content, features='xml')
        items = feed.find_all('item')

        for episode in items:
            is_new_episode = True
            episode_title = episode.title.text
            episode_url = episode.enclosure['url']
            published_date = datetime.strptime(episode.pubDate.text, "%a, %d %b %Y %H:%M:%S %z")
            try:
                episode_image = feed.find('image').find('url').text
            except:
                try:
                    episode_image = feed.find('image')['href']
                except:
                    episode_image = None
            
            if query.exists():
                for old_episode in query:
                    if old_episode.title == episode_title and old_episode.url == episode_url:
                        is_new_episode = False
                    elif old_episode.title == episode_title and old_episode.url != episode_url:
                        old_episode.delete_instance()
            if is_new_episode:
                try:
                    if episode_image:
                        EpisodeDB.create(
                            podcast=PodcastDB.get(PodcastDB.title==self.current_podcast.title),
                            title=episode_title,
                            pub_date=published_date.date(),
                            url=episode_url,
                            image=episode_image,
                            bookmark=0,
                        )
                    else:
                        EpisodeDB.create(
                            podcast=PodcastDB.get(PodcastDB.title==self.current_podcast.title),
                            title=episode_title,
                            pub_date=published_date.date(),
                            url=episode_url,
                            image=self.current_podcast.image,
                            bookmark=0,
                        )
                    self.refresh_episode_list()
                except peewee.IntegrityError:
                    show_error = True
            
        if show_error:
            show_error = False
            vlc_not_installed = qtw.QMessageBox()
            vlc_not_installed.setIcon(qtw.QMessageBox.Warning)
            vlc_not_installed.setText("One or more episodes could not be loaded.")
            vlc_not_installed.setInformativeText("Sorry, we don't support video podcasts yet.")
            vlc_not_installed.setWindowTitle("Invalid Episodes")
                
        qtw.QApplication.restoreOverrideCursor()

    def refresh_episode_list(self):
        qtw.QApplication.setOverrideCursor(qtc.Qt.WaitCursor)
        query = EpisodeDB.select().where(EpisodeDB.podcast == self.current_podcast).order_by(EpisodeDB.pub_date.desc())
        self.ep_list.setRowCount(0)
        today = date.today()
        yesterday = today - timedelta(days=1)
        for episode in query:
            row_data = [episode.pub_date.strftime("%m-%d-%Y"), episode.title]
            row = self.ep_list.rowCount()
            self.ep_list.setRowCount(row+1)
            col = 0
            for item in row_data:
                if item == today.strftime("%m-%d-%Y"):
                    item = "Today"
                elif item == yesterday.strftime("%m-%d-%Y"):
                    item = "Yesterday"
                cell = qtw.QTableWidgetItem(item)
                self.ep_list.setItem(row, col, cell)
                col += 1
        self.ep_list.resizeColumnsToContents()
        qtw.QApplication.restoreOverrideCursor()

    def build_play_view(self, current_episode):
        qtw.QApplication.setOverrideCursor(qtc.Qt.WaitCursor)
        self.just_built_play_view = True
        self.add_podcast_action.setEnabled(False)
        self.remove_podcast_action.setEnabled(False)
        self.refresh_episodes_action.setEnabled(False)
        self.current_episode = EpisodeDB.select().where(EpisodeDB.title == current_episode).get()
        play_layout = qtw.QWidget()
        play_layout.setLayout(qtw.QVBoxLayout())

        back_to_ep_list = qtw.QPushButton("⬅", clicked=self.back_to_episode_list)
        back_to_ep_list.setFixedWidth(50)
        
        ep_image_display = qtw.QLabel()
        
        if self.old_image != self.current_episode.image:
            self.old_image = self.current_episode.image
            request = urllib.request.Request(self.current_episode.image, None, self.headers)
            response = urllib.request.urlopen(request)
            url_image = response.read()
            b64_img = base64.b64encode(url_image)
            current_episode_rendered = b64_img
            self.ep_image = qtg.QPixmap()
            self.ep_image.loadFromData(base64.b64decode(current_episode_rendered))
        ep_image_display.setPixmap(self.ep_image)
        ep_image_display.setScaledContents(True)
        ep_image_display.setFixedSize(300, 300)
        ep_image_display.move(0, 200)
        ep_image_display.setAlignment(qtc.Qt.AlignCenter)

        # Podcast title scroll or not
        self.podcast_title = qtw.QLabel()
        self.podcast_title.setText(self.current_podcast.title)
        text_width = self.podcast_title.fontMetrics().boundingRect(self.podcast_title.text()).width()
        if text_width > self.start_width_resize:
            self.podcast_title = QMarqueeLabel()
            self.podcast_title.setDirection(qtc.Qt.RightToLeft)
        self.podcast_title.setFixedWidth(self.start_width_resize)
        self.podcast_title.move(0, 100)
        self.podcast_title.setAlignment(qtc.Qt.AlignCenter)

        # Episode title scroll or not
        self.episode_title = qtw.QLabel()
        self.episode_title.setText(self.current_episode.title)
        self.ep_text_width = self.episode_title.fontMetrics().boundingRect(self.episode_title.text()).width()
        if self.ep_text_width > self.start_width_resize:
            self.episode_title = QMarqueeLabel()
            self.episode_title.setDirection(qtc.Qt.RightToLeft)
        self.episode_title.setFixedWidth(self.start_width_resize)
        self.episode_title.move(0, 100)
        self.episode_title.setAlignment(qtc.Qt.AlignCenter)

        self.position_elapsed_time = qtw.QLabel("00:00")
        self.position_slider = QJumpSlider(qtc.Qt.Horizontal)
        self.position_slider.setMaximum(1000)
        self.position_total_time = QClickLabel()
        self.position_total_time.clicked.connect(self.position_total_time_clicked)
        self.ep_play = qtw.QPushButton("►", clicked=self.play_episode)
        self.ep_play.setFixedHeight(45)
        ep_skip_back = qtw.QPushButton("⟲", clicked=self.skip_back)
        ep_skip_fwd = qtw.QPushButton("⟳", clicked=self.skip_forward)
        self.playback_speed_btn = qtw.QPushButton(f"{self.playback_speed_val}x", clicked=self.set_playback_speed)
        self.playback_speed_btn.setFixedWidth(50)

        controls_layout = qtw.QWidget()
        controls_layout.setLayout(qtw.QHBoxLayout())
        controls_layout.layout().addWidget(ep_skip_back)
        controls_layout.layout().addWidget(self.ep_play)
        controls_layout.layout().addWidget(ep_skip_fwd)

        position_layout = qtw.QWidget()
        position_layout.setLayout(qtw.QHBoxLayout())
        position_layout.layout().addWidget(self.position_elapsed_time)
        position_layout.layout().addWidget(self.position_slider)
        position_layout.layout().addWidget(self.position_total_time)

        play_layout.layout().addWidget(back_to_ep_list)
        play_layout.layout().addWidget(ep_image_display, alignment=qtc.Qt.AlignCenter)
        play_layout.layout().addWidget(self.podcast_title, alignment=qtc.Qt.AlignCenter)
        play_layout.layout().addWidget(self.episode_title, alignment=qtc.Qt.AlignCenter)
        play_layout.layout().addWidget(position_layout)
        play_layout.layout().addWidget(controls_layout)
        play_layout.layout().addWidget(self.playback_speed_btn)
        self.setCentralWidget(play_layout)
        self.resize(355, 600)
        
        self.play_view = True

        if self.track != self.current_episode.url:
            self.track = self.current_episode.url
            if self.player and self.player.is_playing():
                self.player.stop()
            self.player = vlc.MediaPlayer(self.track)
            self.podcast_title.setText(self.current_podcast.title)
            self.episode_title.setText(self.current_episode.title)
            self.is_paused = False
            self.play_episode()
            if self.current_episode.bookmark != 0:
                self.show_track_time_elapsed()
        else:
            if self.player and self.player.is_playing():
                self.timer.start()
                self.podcast_title.setText(self.current_podcast.title)
                self.episode_title.setText(self.current_episode.title)
                self.get_total_track_time()
                self.ep_play.setText("Ⅱ")
            elif self.player and not self.player.is_playing():
                if self.current_episode.bookmark != 0:
                    self.show_track_time_elapsed()
        qtw.QApplication.restoreOverrideCursor()

    def play_episode(self):
        if not self.player.is_playing():
            if self.is_paused:
                self.ep_play.setText("Ⅱ")
                self.player.pause()
                self.is_paused = False
            else:
                self.ep_play.setText("Ⅱ")
                self.player.play()
                while not self.player.is_playing():
                    time.sleep(0.5)
                if self.current_episode.bookmark != 0:
                    self.player.set_time(self.current_episode.bookmark)
                self.get_total_track_time()

            self.player.set_rate(self.playback_speed_val)
            self.timer.start()
        else:
            self.ep_play.setText("►")
            self.player.pause()
            self.is_paused = True
            self.timer.stop()

    def play_episode_shortcut(self):
        if self.player and self.ep_play:
            try:
                self.play_episode()
            except RuntimeError:
                pass

    def back_to_episode_list(self):
        self.play_view = False
        self.build_episode_view(self.current_podcast.title)
        
    def build_mini_player(self, which_layout):
        if self.player and self.player.is_playing():
            mini_player = qtw.QWidget()
            mini_player.setLayout(qtw.QHBoxLayout())
            second_col = qtw.QWidget()
            second_col.setLayout(qtw.QVBoxLayout())
            
            # Rebuild Track Title
            self.episode_title = qtw.QLabel()
            self.episode_title.setText(self.current_episode.title)
            self.ep_text_width = self.episode_title.fontMetrics().horizontalAdvance(self.episode_title.text())
            if self.ep_text_width > self.position_slider.frameGeometry().width():
                self.episode_title = QMarqueeLabel()
                self.episode_title.setDirection(qtc.Qt.RightToLeft)
                self.episode_title.setText(self.current_episode.title)
            self.episode_title.setAlignment(qtc.Qt.AlignCenter)
            
            second_col.layout().addWidget(self.episode_title)
            second_col.layout().addWidget(self.position_slider)
            
            mini_player.layout().addWidget(self.ep_play)
            mini_player.layout().addWidget(second_col)
            
            mini_player.setFixedHeight(75)
            
            # Add mini player to current widget
            which_layout.layout().addWidget(mini_player)
            
    def build_about_view(self, ap_selection):
        qtw.QApplication.setOverrideCursor(qtc.Qt.WaitCursor)
        self.add_podcast_action.setEnabled(False)
        self.remove_podcast_action.setEnabled(False)
        self.refresh_episodes_action.setEnabled(False)
        about_layout = qtw.QWidget()
        about_layout.setLayout(qtw.QVBoxLayout())

        back_to_search = qtw.QPushButton("⬅", clicked=self.build_add_podcast)
        back_to_search.setFixedWidth(50)
        
        podcast_image_display = qtw.QLabel()
        
        if self.currently_top_100:
            ap = itunes.lookup(int(ap_selection['id']))
            if ap.json.keys() >= {"feedUrl"}:
                ap_url = ap.json['feedUrl']
            else:
                qtw.QApplication.restoreOverrideCursor()
                self.invalid_url_warning()
                return
        else:
            ap_url = ap_selection['url']
            

        feed_req = requests.get(ap_url)
        feed = BeautifulSoup(feed_req.content, features='xml')
        feed_title = feed.find('title').text
        try:
            feed_image = feed.find('image').find('url').text
        except:
            feed_image = feed.find('image')['href']

        feed_description = feed.find('description').text
        feed_author = "by " + feed.find('author').text

        request=urllib.request.Request(feed_image, None, self.headers)
        response = urllib.request.urlopen(request)
        url_image = response.read()
        podcast_image = qtg.QPixmap()
        podcast_image.loadFromData(url_image)
        podcast_image_display.setPixmap(podcast_image)
        podcast_image_display.setScaledContents(True)
        podcast_image_display.setFixedSize(250, 250)
        podcast_image_display.move(0, 200)
        podcast_image_display.setAlignment(qtc.Qt.AlignCenter)
        
        podcast_title = qtw.QLabel(feed_title)
        podcast_title.setStyleSheet('font-weight:bold')
        text_width = podcast_title.fontMetrics().boundingRect(podcast_title.text()).width()
        if text_width > self.start_width_resize:
            podcast_title = QMarqueeLabel(feed_title)
            podcast_title.setDirection(qtc.Qt.RightToLeft)
        podcast_title.setFixedWidth(self.start_width_resize)
        podcast_title.move(0, 100)
        podcast_title.setAlignment(qtc.Qt.AlignCenter)
        description_words = feed_description.split()
        description = ""
        if len(description_words) > 90:
            for i in range(90):
                description += description_words[i] + " "
            description += "..."
        else:
            description = feed_description
        podcast_description = qtw.QLabel(description)
        podcast_description.setWordWrap(True)
        artist_names_lbl = qtw.QLabel(feed_author)
        artist_names_lbl.setWordWrap(True)
        artist_names_lbl.setStyleSheet('font-style:italic')
        subscribe_btn = qtw.QPushButton("Subscribe", clicked=lambda: self.add_podcast_to_library(ap_selection))
        subscribe_btn.setFixedWidth(300)
        podcast_description.setFixedHeight(270)
        podcast_description.setAlignment(qtc.Qt.AlignTop)
        
        about_layout.layout().addWidget(back_to_search)
        about_layout.layout().addWidget(podcast_image_display, alignment=qtc.Qt.AlignCenter)
        about_layout.layout().addWidget(subscribe_btn, alignment=qtc.Qt.AlignCenter)
        about_layout.layout().addWidget(podcast_title, alignment=qtc.Qt.AlignCenter)
        about_layout.layout().addWidget(artist_names_lbl)
        about_layout.layout().addWidget(podcast_description)

        self.setCentralWidget(about_layout)
        qtw.QApplication.restoreOverrideCursor()

    def get_total_track_time(self):
        '''
        Find the total length of the track.
        Display the length in the label to the right of the
        position_slider.
        '''
        self.total_track_length = self.player.get_length() / 1000
        length_gmtime = time.gmtime(self.total_track_length)
        if self.total_track_length >= 3600:
            self.ttl_string = time.strftime("%-H:%M:%S", length_gmtime)
            pixels_wide = self.fontMetrics().horizontalAdvance("-0:00:00")
        else:
            self.ttl_string = time.strftime("%M:%S", length_gmtime)
            pixels_wide = self.fontMetrics().horizontalAdvance("-00:00")
        self.position_total_time.setFixedWidth(pixels_wide)
        self.position_total_time.setText(self.ttl_string)

    def position_total_time_clicked(self):
        if self.ptt_to_prt:
            self.ptt_to_prt = False
            self.position_total_time.setText(self.ttl_string)
        else:
            self.ptt_to_prt = True

    def skip_back(self):
        if self.player and self.player.is_playing():
            rewind = self.player.get_time() - 10000
            if rewind < 0:
                rewind = 0
            self.player.set_time(rewind)

    def skip_forward(self):
        if self.player and self.player.is_playing():
            self.player.set_time(self.player.get_time() + 15000)

    def set_position(self, clicked_pos):
        '''
        Set the place in the audio track based on the slider.
        '''
        self.timer.stop()
        self.player.set_position(clicked_pos / 1000)
        self.timer.start()
    
    def set_playback_speed(self):
        if self.player:
            self.playback_speed_val += .25
            if self.playback_speed_val > 2:
                self.playback_speed_val = 1
            self.player.set_rate(self.playback_speed_val)
            self.playback_speed_btn.setText(f"{self.playback_speed_val}x")

    def to_play_view(self):
        self.build_play_view(self.current_episode.title)
        
    def show_track_time_elapsed(self):
        # Show track time elapsed
        self.track_time_elapsed = self.player.get_time() / 1000
        tte_gmtime = time.gmtime(self.track_time_elapsed)
        if self.total_track_length >= 3600:
            tte_string = time.strftime("%-H:%M:%S", tte_gmtime)
            if self.just_built_play_view:
                pixels_wide = self.fontMetrics().horizontalAdvance("0:00:00")
        else:
            tte_string = time.strftime("%M:%S", tte_gmtime)
            if self.just_built_play_view:
                pixels_wide = self.fontMetrics().horizontalAdvance("00:00")
        if self.just_built_play_view:
            self.position_elapsed_time.setFixedWidth(pixels_wide)
            self.just_built_play_view = False
        self.position_elapsed_time.setText(tte_string)

    def update_ui(self):
        '''
        Update the slider and other UI elements while the audio is playing.
        '''
        track_position = int(self.player.get_position() * 1000)
        self.position_slider.setValue(track_position)
        
        if self.play_view:
            self.show_track_time_elapsed()

            # If the user chose to display the remaining track time
            if self.ptt_to_prt:
                time_remaining = (self.total_track_length - self.track_time_elapsed) / self.playback_speed_val
                tr_gmtime = time.gmtime(int(time_remaining))
                if self.total_track_length >= 3600:
                    tte_string = time.strftime("-%-H:%M:%S", tr_gmtime)
                else:
                    tte_string = time.strftime("-%M:%S", tr_gmtime)
                self.position_total_time.setText(tte_string)

            # Every 5 seconds, update database to save place in podcast
            rounded_elapsed = int(round(self.track_time_elapsed, 0))
            if rounded_elapsed % 5 == 0:
                # Don't save the same timestamp twice
                if self.already_saved != rounded_elapsed:
                    self.current_episode.bookmark = self.player.get_time()
                    self.current_episode.save()
                    self.already_saved = rounded_elapsed

        # If no media is playing, stop the timer
        if not self.player.is_playing():
            # If player not playing and it's not paused the track is finished
            if not self.is_paused:
                if self.play_view:
                    self.ep_play.setText("►")
                    if self.total_track_length >= 3600:
                        tte_string = '0:00:00'
                    else:
                        tte_string = '00:00'
                    self.position_elapsed_time.setText(tte_string)
                    self.position_slider.setValue(0)
                
                self.player.set_position(0)
                self.player.stop()
                self.current_episode.bookmark = 0
                self.current_episode.save()
                self.try_next_episode()
    
    def try_next_episode(self):
        # Check if there is a newer episode
        ep_date_list = []
        query = EpisodeDB.select().where(EpisodeDB.podcast == self.current_podcast).order_by(EpisodeDB.pub_date.desc())
        if query.exists():
            for episode in query:
                ep_date_list.append(episode.pub_date)
            current_episode_id = ep_date_list.index(self.current_episode.pub_date)
            if current_episode_id != 0:
                # Get the next episode
                next_episode_id = current_episode_id - 1
                self.current_episode = EpisodeDB.select().where(EpisodeDB.pub_date == ep_date_list[next_episode_id]).get()
                self.track = self.current_episode.url
                self.player = vlc.MediaPlayer(self.track)
                # If we are in play view, update all labels.
                if self.play_view:
                    self.podcast_title.setText(self.current_podcast.title)
                    self.episode_title.setText(self.current_episode.title)
                    self.play_episode()
                else:
                    self.player.play()
                    while not self.player.is_playing():
                        time.sleep(0.5)
                    if self.current_episode.bookmark != 0:
                        self.player.set_time(self.current_episode.bookmark)
            else:
                self.timer.stop()
	
    def library_context_menu(self, position):
        if self.lib_podcasts.itemAt(position):
            contextMenu = qtw.QMenu(self)
            remove_action = contextMenu.addAction("Remove Podcast")
            action = contextMenu.exec_(qtg.QCursor.pos())
            if action == remove_action:
                self.remove_podcast(self.lib_podcasts.itemAt(position).text())
                
    def episode_context_menu(self, position):
        contextMenu = qtw.QMenu(self)
        play_action = contextMenu.addAction("Play")
        action = contextMenu.exec_(qtg.QCursor.pos())
        if action == play_action:
            self.build_play_view(self.ep_list.item(self.ep_list.currentRow(),1).text())
            
    def search_context_menu(self, position):
        contextMenu = qtw.QMenu(self)
        about_action = contextMenu.addAction("About")
        action = contextMenu.exec_(qtg.QCursor.pos())
        if action == about_action:
            self.build_about_view(self.results_lod[self.results_list.currentRow()])
    
    @staticmethod
    def get_episode_url(episode):
        links = episode["links"]
        for link in links:
            if "audio" in link["type"]:
                return link["href"]

    @staticmethod
    def icon_from_base64(base64):
        pixmap = qtg.QPixmap()
        pixmap.loadFromData(qtc.QByteArray.fromBase64(base64))
        icon = qtg.QIcon(pixmap)
        return icon

if __name__ == '__main__':
    qtw.QApplication.setAttribute(qtc.Qt.AA_EnableHighDpiScaling, True)
    app = qtw.QApplication(sys.argv)
    mw = MainWindow()
    sys.exit(app.exec())
